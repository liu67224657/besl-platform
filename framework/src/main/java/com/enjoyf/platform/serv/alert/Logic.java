package com.enjoyf.platform.serv.alert;

import com.enjoyf.platform.serv.thrserver.ConnThreadBase;
import com.enjoyf.platform.service.service.HelloInfo;
import com.enjoyf.platform.util.Utility;
import com.enjoyf.platform.util.collection.CircularQueue;
import com.enjoyf.platform.util.collection.QueueListener;
import com.enjoyf.platform.util.collection.QueueThread;
import com.enjoyf.platform.util.log.Alert;
import com.enjoyf.platform.util.log.AlertImpl;
import com.enjoyf.platform.util.log.AlertType;
import com.enjoyf.platform.util.log.GAlerter;
import com.enjoyf.platform.util.thin.DieThread;

/**
 * The Logic class holds the core logic for the server.
 * This class is expected to change almost completely from
 * server to server. <p>
 */

class Logic {
    /**
     * The config object.
     */
    private Config config;

    /**
     * A container which keeps track of clients. A client is
     * a connection.
     */
    private ClientContainer clientContainer = new ClientContainer();

    /**
     * We will log all msgs on a separate thread so as to not tie down
     * request threads.
     */
    private QueueThread queueThread;

    /**
     * Use another object to redirect the alerts to all manner of
     * listeners.
     */
    private AlertProcessor alertProcessor = new AlertProcessor();

    private AlertProcessorFile defaultLogger;
    private Client thisClient;

    Logic(Config cfg) {
        config = cfg;

        //--
        // Create a dummy Client object for our own alerts from this
        // process.
        //--
        thisClient = new Client("alert", "alert-ip");

        //--
        // Must set our own alert logger since we don't want to be
        // going in circles sending out alerts to ourselves, especially
        // when the alerts are generated by the AlertPacketDecoder.
        //--
        GAlerter.setImpl(
                new AlertImpl() {
                    public void log(Alert alert) {
                        ServerAlert serverAlert = new ServerAlert(thisClient, alert);
                        defaultLogger.process(serverAlert);
                    }

                    public void flush() {
                    }

                    public void close() {
                    }
                }
        );

        queueThread = new QueueThread(
                new QueueListener() {
                    public void process(Object obj) {
                        p_process((ServerAlert) obj);
                    }
                }
                , new CircularQueue(100)
        );

        // Set up a thread that just prints a heartbeat to one of the
        // outputs.
        if (config.getHeartbeat() != 0) {
            (new Heartbeat()).start();
        }

        // Register all the listener objects. Keep track of one
        // for any alerts that are issued by this server.
        defaultLogger = new AlertProcessorFile("all.txt", config.getMinFileSize());

        alertProcessor.addListener(AlertType.BUG, new AlertProcessorFile("bug.txt", config.getMinFileSize()));
        alertProcessor.addListener(AlertType.BUG, defaultLogger);

        alertProcessor.addListener(AlertType.NOISE, new AlertProcessorFile("noise.txt", config.getMinFileSize()));
        alertProcessor.addListener(AlertType.NOISE, defaultLogger);

        alertProcessor.addListener(AlertType.CLIENT_BUG, new AlertProcessorFile("client_bug.txt", config.getMinFileSize()));
        alertProcessor.addListener(AlertType.CLIENT_BUG, defaultLogger);

        // A special bucket for msgs that are really just for debugging
        alertProcessor.addListener(AlertType.DEBUG, new AlertProcessorFile("debug.txt", config.getMinFileSize()));

        alertProcessor.addListener(AlertType.TIMER_DEBUG, new AlertProcessorFile("timer_debug.txt", config.getMinFileSize()));
    }


    Config getCfg() {
        return config;
    }

    void hello(ConnThreadBase conn, HelloInfo hinfo) {
        //--
        // Note how we really don't use the HelloInfo object, we assume
        // that every connect is a fresh connect. It is the responsibility
        // of the client to synch up.
        //--
        Client client = new Client(hinfo.getName(), conn.getIp());
        clientContainer.add(conn, client);
    }

    /**
     * Log a msg via the queue thread.
     */
    void log(ConnThreadBase conn, Alert alert) {
        Client c = clientContainer.get(conn);

        //--
        // It's quite possible for there to be a race condition where
        // a packet comes in, a conn dies, and then we execute this code
        // after we've removed the Client from our container. So just
        // make a Client object up.
        //--
        if (c == null) {
            c = new Client(conn.toString(), conn.getIp());
        }

        queueThread.add(new ServerAlert(c, alert));
    }

    /**
     * This will be called when a connection has died.
     */
    void connDied(ConnThreadBase conn) {
        clientContainer.remove(conn);
    }

    private void p_process(ServerAlert serverAlert) {
        alertProcessor.process(serverAlert);
    }

    class Heartbeat extends DieThread {
        public void run() {
            while (!shouldDie()) {
                Utility.sleep(config.getHeartbeat());

                Alert alert = new Alert(AlertType.NOISE, "I'm live.");
                ServerAlert m = new ServerAlert(thisClient, alert);

                queueThread.add(m);
            }
        }
    }
}
